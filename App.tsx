
import React, { useState, useEffect, Suspense, lazy } from 'react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import Layout from './components/Layout';
import { Auth } from './components/Auth';
import { Post, PostStatus, Activity, VoiceProfile, UserPreferences } from './types';
import { Search, Loader2 } from 'lucide-react';
import { supabase } from './lib/supabase';
import { generateDraftFromActivity } from './services/geminiService';
import { subscribeToUserUpdates } from './lib/pusher';
import { DashboardSkeleton, ComposerSkeleton } from './components/Skeleton';
import { trackEvent, trackError } from './lib/monitoring';

// Lazy load heavy components for code-splitting
const Dashboard = lazy(() => import('./components/Dashboard'));
const Composer = lazy(() => import('./components/Composer'));
const ActivityFeed = lazy(() => import('./components/ActivityFeed'));
const ContentQueue = lazy(() => import('./components/ContentQueue'));
const VoiceProfileSettings = lazy(() => import('./components/VoiceProfileSettings'));
const AnalyticsView = lazy(() => import('./components/AnalyticsView'));
const SettingsPanel = lazy(() => import('./components/SettingsPanel'));
const SchedulerView = lazy(() => import('./components/SchedulerView'));

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes cache
      gcTime: 10 * 60 * 1000,
    },
  },
});

const AppContent: React.FC = () => {
  const [session, setSession] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const [activeTab, setActiveTab] = useState('dashboard');
  const [posts, setPosts] = useState<Post[]>([]);
  const [activities, setActivities] = useState<Activity[]>([]);
  const [preferences, setPreferences] = useState<UserPreferences>({
    autoPublish: false,
    useEmojis: true,
    defaultPlatform: 'LinkedIn',
    notificationsEnabled: true,
    theme: 'system'
  });
  const [voiceProfiles, setVoiceProfiles] = useState<VoiceProfile[]>([
    {
      id: 'p1',
      name: 'Professional Tech',
      tone: 85,
      technicality: 90,
      humor: 20,
      length: 60,
      examples: 'Our latest research into CRDTs shows a 40% reduction in sync latency.',
      isDefault: true
    }
  ]);

  const defaultVoiceProfile = voiceProfiles.find(p => p.isDefault);

  useEffect(() => {
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      setLoading(false);
    });
    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      setSession(session);
    });
    return () => subscription.unsubscribe();
  }, []);

  useEffect(() => {
    if (!session?.user?.id) return;
    return subscribeToUserUpdates(session.user.id, {
      onDraftAdded: (data) => setPosts(prev => [data, ...prev]),
      onActivityAdded: (data) => setActivities(prev => [data, ...prev]),
      onStatusUpdated: (data) => setPosts(prev => prev.map(p => p.id === data.id ? { ...p, ...data } : p))
    });
  }, [session]);

  // Handle simulation event from ContentQueue
  useEffect(() => {
    const handleSimulate = async () => {
      if (!session) return;
      
      const sources: ('GitHub' | 'Linear')[] = ['GitHub', 'Linear'];
      const source = sources[Math.floor(Math.random() * sources.length)];
      const title = source === 'GitHub' ? 'Merged PR #102: Refactor auth middleware' : 'Completed: Migration to Postgres Vector';
      const description = source === 'GitHub' 
        ? 'Improved security and reduced latency by 150ms across all authenticated routes.' 
        : 'Enabled high-performance semantic search for the entire resource library.';

      const newActivity: Activity = {
        id: Date.now().toString(),
        source,
        type: 'Technical Update',
        title,
        description,
        significanceScore: 0.85,
        timestamp: new Date(),
        status: 'PROCESSED'
      };

      setActivities(prev => [newActivity, ...prev]);
      trackEvent('activity_simulated', { source });

      // Trigger AI draft generation
      try {
        const result = await generateDraftFromActivity(title, description, preferences.defaultPlatform, defaultVoiceProfile);
        const newPost: Post = {
          id: 'post_' + Date.now(),
          title: result.title,
          content: result.content,
          platform: preferences.defaultPlatform,
          status: PostStatus.AI_DRAFT,
          createdAt: new Date(),
          activityId: newActivity.id,
          source,
          qualityScore: 0.92
        };
        
        // Persist draft to Supabase so backend agents see it
        const { error } = await supabase.from('content_drafts').insert([{
          ...newPost,
          user_id: session.user.id
        }]);
        
        if (error) throw error;
        
        setPosts(prev => [newPost, ...prev]);
        trackEvent('draft_autogenerated', { post_id: newPost.id });
      } catch (err: any) {
        trackError(err, "Simulation generation failed");
      }
    };

    window.addEventListener('simulate_webhook', handleSimulate);
    return () => window.removeEventListener('simulate_webhook', handleSimulate);
  }, [session, preferences.defaultPlatform, defaultVoiceProfile]);

  // Persistence logic (Hydration)
  useEffect(() => {
    if (!session) return;
    const loadInitialData = async () => {
      const { data: dbPosts } = await supabase.from('content_drafts').select('*').order('created_at', { ascending: false });
      const { data: dbActivities } = await supabase.from('activities').select('*').order('timestamp', { ascending: false });
      
      if (dbPosts) setPosts(dbPosts.map((p: any) => ({ ...p, createdAt: new Date(p.created_at), scheduledFor: p.scheduled_for ? new Date(p.scheduled_for) : undefined })));
      if (dbActivities) setActivities(dbActivities.map((a: any) => ({ ...a, timestamp: new Date(a.timestamp) })));
    };
    
    loadInitialData();
  }, [session]);

  // Persistence logic (Local Preferences)
  useEffect(() => {
    if (!session) return;
    const savedPrefs = localStorage.getItem(`prefs_${session.user.id}`);
    const savedVoices = localStorage.getItem(`voices_${session.user.id}`);
    if (savedPrefs) setPreferences(JSON.parse(savedPrefs));
    if (savedVoices) setVoiceProfiles(JSON.parse(savedVoices));
  }, [session]);

  useEffect(() => {
    if (session) {
      localStorage.setItem(`prefs_${session.user.id}`, JSON.stringify(preferences));
      localStorage.setItem(`voices_${session.user.id}`, JSON.stringify(voiceProfiles));
    }
  }, [preferences, voiceProfiles, session]);

  // REAL PERSISTENCE HANDLERS
  const handleApproveDraft = async (id: string) => {
    const scheduledFor = new Date(Date.now() + 86400000);
    
    // Optimistic Update
    setPosts(prev => prev.map(p => 
      p.id === id ? { ...p, status: PostStatus.SCHEDULED, scheduledFor } : p
    ));

    // Persist to Supabase to trigger n8n agents
    const { error } = await supabase
      .from('content_drafts')
      .update({ 
        status: PostStatus.SCHEDULED, 
        scheduled_for: scheduledFor.toISOString() 
      })
      .eq('id', id);

    if (error) {
      trackError(error, "Failed to approve post in database");
      // Rollback would go here in a production app
    } else {
      trackEvent('post_approved', { post_id: id });
    }
  };

  const handleRejectPost = async (id: string) => {
    setPosts(prev => prev.filter(p => p.id !== id));
    
    const { error } = await supabase
      .from('content_drafts')
      .delete()
      .eq('id', id);

    if (error) trackError(error, "Failed to delete post from database");
    else trackEvent('post_rejected', { post_id: id });
  };

  const handlePublishPost = async (id: string) => {
    setPosts(prev => prev.map(p => p.id === id ? { ...p, status: PostStatus.PUBLISHED } : p));
    
    const { error } = await supabase
      .from('content_drafts')
      .update({ status: PostStatus.PUBLISHED })
      .eq('id', id);

    if (error) trackError(error, "Failed to publish post in database");
    else trackEvent('post_published', { post_id: id });
  };

  if (loading) return (
    <div className="min-h-screen flex items-center justify-center bg-slate-50">
      <Loader2 className="w-8 h-8 animate-spin text-indigo-600" />
    </div>
  );

  if (!session) return <Auth />;

  return (
    <Layout activeTab={activeTab} setActiveTab={setActiveTab} user={session.user}>
      <Suspense fallback={activeTab === 'dashboard' ? <DashboardSkeleton /> : <div className="p-8 text-center text-slate-400">Loading module...</div>}>
        {activeTab === 'dashboard' && <Dashboard posts={posts} />}
        {activeTab === 'composer' && <Composer onSave={async (p) => { 
           const { error } = await supabase.from('content_drafts').insert([{ ...p, user_id: session.user.id }]);
           if (!error) { setPosts(prev => [p, ...prev]); setActiveTab('dashboard'); }
        }} defaultVoiceProfile={defaultVoiceProfile} />}
        {activeTab === 'activities' && <ActivityFeed activities={activities} />}
        {activeTab === 'voices' && <VoiceProfileSettings profiles={voiceProfiles} onSave={(v) => setVoiceProfiles(prev => [...prev.filter(x => x.id !== v.id), v])} />}
        {activeTab === 'analytics' && <AnalyticsView posts={posts} />}
        {activeTab === 'settings' && <SettingsPanel user={session.user} preferences={preferences} onUpdatePreferences={setPreferences} />}
        {activeTab === 'scheduler' && <SchedulerView posts={posts} />}
        {activeTab === 'queue' && (
          <ContentQueue 
            posts={posts} 
            onApprove={handleApproveDraft} 
            onReject={handleRejectPost}
            onEdit={(id) => setActiveTab('composer')}
            onPublish={handlePublishPost}
          />
        )}
      </Suspense>
    </Layout>
  );
};

const App: React.FC = () => (
  <QueryClientProvider client={queryClient}>
    <AppContent />
  </QueryClientProvider>
);

export default App;
